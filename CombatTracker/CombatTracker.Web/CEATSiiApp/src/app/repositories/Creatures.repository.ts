


//*************************DO NOT MODIFY**************************
//
//THESE FILES ARE AUTOGENERATED WITH TYPEWRITER AND ANY MODIFICATIONS MADE HERE WILL BE LOST
//PLEASE VISIT http://frhagn.github.io/Typewriter/ TO LEARN MORE ABOUT THIS VISUAL STUDIO EXTENSION
//
//*************************DO NOT MODIFY**************************
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import {Observable, throwError} from "rxjs";
import { map, catchError } from "rxjs/operators";

    import * as Enums from '@/entities/EnumDefinitions'
    import { Creature } from '@/entities';

var version = "1.0";

@Injectable({ providedIn: 'root' })
export class CreaturesRepository {

    constructor(private _httpClient: HttpClient) { }
    
    // get: api/v${version}/Creatures/getCreatures

	//public getCreatures = (, callback: (data: Creature[])=>void) : void => {
	//	this.getCreaturesObserve().subscribe(response => callback(response));
	//}

	public getCreaturesAsync = () : Promise<Creature[]> => {

        return new Promise<Creature[]>((resolve, reject) => {
            this.getCreatures()
            .subscribe((res) => {
                    resolve(res);
                });

        });
	}

	public getCreatures = () : Observable<Creature[]> => {
        
        var _Url = `api/v${version}/Creatures/getCreatures`;
            return this._httpClient.get<Creature[]>(_Url)
                .pipe(catchError(this.handleError));
	};

    
    // get: api/v${version}/Creatures/getCreature/${id}

	//public getCreature = (id: number, callback: (data: Creature)=>void) : void => {
	//	this.getCreatureObserve(id).subscribe(response => callback(response));
	//}

	public getCreatureAsync = (id: number) : Promise<Creature> => {

        return new Promise<Creature>((resolve, reject) => {
            this.getCreature(id)
            .subscribe((res) => {
                    resolve(res);
                });

        });
	}

	public getCreature = (id: number) : Observable<Creature> => {
        id = (id == null ? <number><any>"" : id);
        
        var _Url = `api/v${version}/Creatures/getCreature/${id}`;
            return this._httpClient.get<Creature>(_Url)
                .pipe(catchError(this.handleError));
	};

    
    // post: api/v${version}/Creatures/SaveCreature

	//public saveCreature = (creature: Creature, callback: (data: Creature)=>void) : void => {
	//	this.saveCreatureObserve(creature).subscribe(response => callback(response));
	//}

	public saveCreatureAsync = (creature: Creature) : Promise<Creature> => {

        return new Promise<Creature>((resolve, reject) => {
            this.saveCreature(creature)
            .subscribe((res) => {
                    resolve(res);
                });

        });
	}

	public saveCreature = (creature: Creature) : Observable<Creature> => {
        creature = (creature == null ? <Creature><any>"" : creature);
        
        var _Url = `api/v${version}/Creatures/SaveCreature`;
            return this._httpClient.post<Creature>(_Url, creature)
                .pipe(catchError(this.handleError));
	};

    
    // delete: api/v${version}/Creatures/deleteCreature/${id}

	//public deleteCreature = (id: number, callback: (data: void)=>void) : void => {
	//	this.deleteCreatureObserve(id).subscribe(response => callback(response));
	//}

	public deleteCreatureAsync = (id: number) : Promise<void> => {

        return new Promise<void>((resolve, reject) => {
            this.deleteCreature(id)
            .subscribe((res) => {
                    resolve(res);
                });

        });
	}

	public deleteCreature = (id: number) : Observable<void> => {
        id = (id == null ? <number><any>"" : id);
        
        var _Url = `api/v${version}/Creatures/deleteCreature/${id}`;
            return this._httpClient.delete<void>(_Url)
                .pipe(catchError(this.handleError));
	};

    
    // Utility
    private handleError(error: HttpErrorResponse) {
        console.error(error);
        let customError: string = "";
        if (error.error) {
            customError = error.status === 400 ? error.error : error.statusText
        }
        return Observable.throw(customError || 'Server error');
    }
}




